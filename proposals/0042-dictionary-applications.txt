Notes on reStructuredText - delete this section before submitting
==================================================================

The proposals are submitted in reStructuredText format.  To get inline code, enclose text in double backticks, ``like this``.  To get block code, use a double colon and indent by at least one space

::

 like this
 and

 this too

To get hyperlinks, use backticks, angle brackets, and an underscore `like this <http://www.haskell.org/>`_.


Explicit Dictionary Applications
================================

.. proposal-number:: Leave blank. This will be filled in when the proposal is
                     accepted.
.. trac-ticket:: Leave blank. This will eventually be filled with the Trac
                 ticket number which will track the progress of the
                 implementation of the feature.
.. implemented:: Leave blank. This will be filled in with the first GHC version which
                 implements the described feature.
.. highlight:: haskell
.. header:: This proposal is `discussed at this pull request <https://github.com/ghc-proposals/ghc-proposals/pull/0>`_.
            **After creating the pull request, edit this file again, update the
            number in the link, and delete this bold sentence.**
.. sectnum::
.. contents::

This proposed GHC extension adds a form of explicit dictionary applications without compromising global instance uniqueness and uniqueness.
It is based on the paper [Coherent Dictionary Applications for Haskell][https://dl.acm.org/citation.cfm?id=3242752] by Winant and Devriese.
The proposal consists of a number of interconnected components that we explain below.

Motivation
------------
In many situations, it would be useful to be able to instantiate a type class constraint with a custom implementation of the type class.
The obvious example that comes to mind is the nub method in the Prelude.

  nub :: Eq a => [a] -> [a]

In this case, Prelude offers the nub function for all types a for which the ``Eq`` type class is instantiated.
The function filters duplicates from a list:

  nub ["abc", "def", "aBc", "abc"] = ["abc", "def", "aBc"]

However, often we want to use such a function with a non-standard notion of equality.
In this case, we can use an alternative function offered by the Prelude:

  nubBy :: (a -> a -> Bool) -> [a] -> [a] -> Bool
  nubBy ((==) `on` map toLower) ["abc", "def", "aBc", "abc"] = ["abc", "def", "aBc"]

However, this only works because the Prelude exposes two interfaces to the same method, implementing one in terms of the other.
Expecting all library authors to do this for all methods with type class constraints is hardly realistic, if only because of the overhead of implementing both versions for all functions.

In situations where library authors didn't have the foresight to provide a ``nubBy`` version of a function with a constraint ``nub``, there exist a number of workarounds.
One approach is to define a newtype wrapper:

  newtype StringCI = MkStringCI { unStringCI :: String }
  instance Eq StringCI where
    (==) = (==) `on` (map toLower . unStringCI)

This works if the alternative instance we want to give can be defined as a top-level instance.
Imagine that we want to use nub with equality-modulo-k in a function that takes k as an argument.

  newtype IntModK = MkIntModK { unIntModK :: Int }
  instance Eq IntModK where
    (==) = (==) `on` (`mod` k) -- k is not in scope here?
    
  f :: Int -> [Int] -> [Int]
  f k = map unIntModK . nub . map MkIntModK

In this case, we cannot give the instance we want to give because the instance
for our newtype must necessarily be toplevel (like all instances) and cannot
mention local values like ``k``.

For this problem too, there are solutions, particularly the
[reflection][http://hackage.haskell.org/package/reflection] library, based on
the `implicit configurations <https://dl.acm.org/citation.cfm?id=1017481>` paper
by Kiselyov and Shan.

  newtype IntMod s = MkIntMod { unIntMod :: proxy s -> Int }
  instance Reifies s Int => Eq (IntMod s) where
    (==) = (==) `on` (`mod` reflect (Proxy @ s))

  f :: Int -> [Int] -> [Int]
  f k = reify k $ \ ps -> map (unIntMod ps) . nub . map (MkIntMod . const)

While this works for our example, it comes with quite some technical complexity (phantom type variable s, infrastructure like Reifies, reify, reflect etc.).
Additionally, it becomes a bit annoying to use in more complex situations (but let's not go into this to avoid derailing the discussion).

Our proposal is more direct: we propose to allow explicit dictionary applications that look as follows:

  mkEqDict :: (a -> a -> Bool) -> Eq.Dict a
  mkEqDict eq = Eq.Dict eq (\ x y -> not (eq x y))

  f :: Int -> [Int] -> [Int]
  f k = nub @ (mkEqDict ((==) `on` (`mod` k)))

However, naively adding dictionary applications is dangerous for two reasons. The first is illustrated below:

  twoEqs :: (Eq a, Eq a) => a -> a -> Bool
  twoEqs = (==)

  coherenceProblem = (twoEqs @ mkEqDict (\ _ _ -> True)) 1 2

In this case, we instantiate one ``Eq a`` instance of a function that takes two.
However, inside ``twoEqs``, it depends on details of the constraint solver which one will be used, and so does the result of ``coherenceProblem``.

The second problem is that some libraries rely on a property called `global instance uniqueness <http://blog.ezyang.com/2014/07/type-classes-confluence-coherence-global-uniqueness/>`_.
An example from the paper by Winant and Devriese is the following:

  insert :: Ord a ⇒ a → Set a → Set a
  empty :: Set a
  reverseOrd :: Ord a ⇒ Ord.Dict a
  reverseOrd = Ord.Dict { compare = flip compare }

  insert @ {reverseOrd} 1 (insert 1 (insert 2 empty)) = fromList [1, 2, 1]

What happens here is that the Data.Set API relies on the fact that if `insert` is used multiple times on the same tree, it will always happen with the same `Ord` instance.
By violating this assumption (as above), we can break the library's invariants.

Proposed Change Specification
-----------------------------
The proposal consists of a number of related additions:

Dictionary types
^^^^^^^^^^^^^^^^

For every type class definition like the following:

  class C1 x1s, C2 x2s, ..., Cn xns => C x1 ... xn where
    m1 :: T1
    m2 :: T2
    ..
    mn :: Tn

We now also expose a datatype ``C.Dict``, equivalent to the following data type definition:

  data C.Dict x1 ... xn = C.Dict {
       parent1 :: C1.Dict x1s
     , parent2 :: C2.Dict x2s
     , ...
     , parentn :: Cn.Dict xns
     , m1 :: T1
     , ...
     , mn :: Tn
    }

The name ``C.Dict`` is tentative and subject to bikeshedding, and we haven't looked closely into possible conflicts with other syntax.


Dictionary applications
^^^^^^^^^^^^^^^^^^^^^^^

TODO


[OPTIONAL] Dictionary Instances
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TODO


Effect and Interactions
-----------------------
Detail how the proposed change addresses the original problem raised in the motivation.

Discuss possibly contentious interactions with existing language or compiler features. 


Costs and Drawbacks
-------------------
Give an estimate on development and maintenance costs. List how this effects learnability of the language for novice users. Define and list any remaining drawbacks that cannot be resolved.


Alternatives
------------
List existing alternatives to your proposed change as they currently exist and discuss why they are insufficient.


Unresolved Questions
--------------------
Explicitly list any remaining issues that remain in the conceptual design and specification. Be upfront and trust that the community will help. Please do not list *implementation* issues.

Hopefully this section will be empty by the time the proposal is brought to the steering committee.


Implementation Plan
-------------------

A proof of concept implementation was implemented by Thomas Winant as `a fork of GHC <ssh://git@dnetcode.cs.kuleuven.be:2222/explicit-dictionaries-ghc.git>`_.
It is usable but quite a long way from ready.
TODO: more details.

(Optional) If accepted who will implement the change? Which other ressources and prerequisites are required for implementation?
